<?php

namespace Drupal\cgov_js_app_module\Plugin\app_module;

use Drupal\Core\Cache\CacheableMetadata;
use Drupal\Core\Language\LanguageManagerInterface;
use Drupal\Core\Url;
use Drupal\Core\Utility\Token;
use Drupal\app_module\Plugin\app_module\AppModulePluginBase;
use Drupal\cgov_js_app_module\Render\JsAppModuleScriptMarkup;
use Exception;
use Symfony\Component\DependencyInjection\ContainerInterface;

/**
 * JS-Only App Module Plugin.
 *
 * This app_module/plugin is used for those React-based app modules that
 * do not need any back-end Drupal support. This does require that the
 * app modules follow a specific config format for the JSON data. Until
 * app modules have the ability to draw a UI for their options, OR at
 * least some validation method exists, the following will have to do.
 * (Please be careful)
 *
 * @code
 * {
 *   "drupalConfig": {
 *      "appName": "your-apps-name-here",
 *      "rootId": "NCI-app-root",
 *      "initFnName": "window.appModuleInit",
 *      "appCssUri": "https://someserver/app-name/app-name.vX.Y.Z.css",
 *      "appJsUri": "https://someserver/app-name/app-name.vX.Y.Z.js",
 *      "removeHeadElements" : [
 *        ...
 *      ],
 *      "validAppPaths": [
 *        ".*"
 *      ]
 *   },
 *   "frontEndConfig": {
 *     ...This will be passed into the initialize function...
 *   }
 * }
 * @endcode
 *
 * The config has two parts:
 * - drupalConfig -- this is configuration for Drupal to know how to
 *   load the app.
 * - frontEndConfig -- this is configuration for the app itself. This will be
 *   passed into the initialize method. (It will be combined with some other
 *   Drupal path information.) You can make this whatever you want.
 *
 * The drupalConfig is made up of the following:
 * - appName -- This is a unique ID for your app. (e.g. 'glossary-app-doct')
 *   try and make multiple instances of the app have a unique name please.
 *   NOTE: This must be appropriate for being the key of an array.
 * - rootId -- this is the ID of the div tag for this instance, and what will
 *   get passed into the initialize function.
 * - initFnName -- The full name of the init function, we assume the app'
 *   init function will be attached to the window, but please include that
 *   too.
 * - pathToCss -- This is the full URL to the CSS file for the app. Make sure
 *   it has a version number, and never update that asset. (Or caching issues
 *   will occur)
 * - pathToJs -- This is the full URL to the JS file for the app. Make sure
 *   it has a version number, and never update that asset. (Or caching issues
 *   will occur)
 * - removeHeadElements -- The Drupal head elements your module will handle
 *   and should not be generated by Drupal lest Google get the wrong
 *   information. This list maps to keys in
 *   $attachments['#attached']['html_head'], except for 'alternate' which will
 *   remove any <link rel="alternate"> elements. A key for the <title> tag has
 *   been added, 'title_tag'.
 *   We had added react-helmet attributes to tags so the app
 *   would not generate dupes, but at this point, just remove them and then have
 *   your app generate everywhere.
 * - validAppPaths -- This is a list of regular expressions that will ensure
 *   that your app has a route for that path. '/' is always allowed, so this is
 *   for any URL OTHER than '/'. If the requested path does not
 *   match, then a 404 is retured. The path is RELATIVE TO YOUR APP. So if the
 *   url of your app is /foo/bar and the route is /chicken/:someID, then enter
 *   "\\/chicken\\/.*". (NOTE: You need to escape backslashes in JSON)
 *
 * @AppModulePlugin(
 *   id = "cgov_js_only_app_module_plugin",
 *   label = @Translation("JS-Only App Module Plugin")
 * )
 */
class JsOnlyAppModulePlugin extends AppModulePluginBase {

  /**
   * Directive for a literal, i.e. do not add double quotes.
   */
  const LITERAL_DIRECTIVE = "@@LITERAL@@";

  /**
   * Directive to no JSON Encode, i.e. add double quotes, but no escape chars.
   */
  const NOENC_DIRECTIVE = "@@NOENCODE@@";

  /**
   * Directive to pass the text to the Drupal token service.
   */
  const TOKEN_DIRECTIVE = "@@TOKEN@@";

  /**
   * The Drupal language manager.
   *
   * @var \Drupal\Core\Language\LanguageManagerInterface
   */
  protected $languageManager;

  /**
   * Token Service.
   *
   * @var \Drupal\Core\Utility\Token
   */
  protected $tokenService;

  /**
   * Constructs a AppModulePluginBase object.
   *
   * @param array $configuration
   *   A configuration array containing information about the plugin instance.
   * @param string $plugin_id
   *   The plugin_id for the plugin instance.
   * @param mixed $plugin_definition
   *   The plugin implementation definition.
   * @param \Drupal\Core\Language\LanguageManagerInterface $language_manager
   *   The Drupal language manager.
   * @param \Drupal\Core\Utility\Token $token_service
   *   The Drupal token service.
   */
  public function __construct(
    array $configuration,
    $plugin_id,
    $plugin_definition,
    LanguageManagerInterface $language_manager,
    Token $token_service
  ) {
    parent::__construct($configuration, $plugin_id, $plugin_definition);
    $this->definition = $plugin_definition + $configuration;
    $this->languageManager = $language_manager;
    $this->tokenService = $token_service;
  }

  /**
   * {@inheritdoc}
   */
  public static function create(ContainerInterface $container, array $configuration, $plugin_id, $plugin_definition) {
    return new static(
      $configuration,
      $plugin_id,
      $plugin_definition,
      $container->get('language_manager'),
      $container->get('token')
    );
  }

  /**
   * {@inheritdoc}
   */
  protected function matchRouteInternal(array $path_components, array $options = []) {

    $default_app_route = [
      'app_module_route' => '/',
      'params' => [],
    ];

    if (
      count($path_components) === 0 ||
      empty($options['drupalConfig']['validAppPaths']) ||
      count($options['drupalConfig']['validAppPaths']) === 0 ||
      $this->hasMatchingPath($path_components, $options['drupalConfig']['validAppPaths'])
    ) {
      return $default_app_route;
    }
    else {
      return NULL;
    }

  }

  /**
   * Helper function to determine is a requested path isallowed.
   *
   * @param array $path_components
   *   The requested path broken up into an array.
   * @param array $valid_paths
   *   A collection of regular expressions for paths that are valid.
   *
   * @return bool
   *   TRUE if the path is allowed, FALSE if not.
   */
  private function hasMatchingPath(array $path_components, array $valid_paths) {
    $path = implode('/', $path_components);
    $path = '/' . $path;
    foreach ($valid_paths as $regex) {
      if (preg_match('/' . $regex . '/', $path)) {
        return TRUE;
      }
    }
    return FALSE;
  }

  /**
   * {@inheritdoc}
   */
  public function getAppRouteId($path, array $options = []) {
    // There is only one route.
    return 'default';
  }

  /**
   * {@inheritdoc}
   */
  public function buildForRoute($path, array $options = []) {

    $build['app_block'] = [
      '#type' => 'container',
      '#attributes' => [
        'id' => $options['drupalConfig']['rootId'],
      ],
    ];
    $build['app_block']['noscript'] = [
      '#type' => 'html_tag',
      '#tag' => 'noscript',
      '#value' => 'You need to enable JavaScript to run this app.',
    ];

    $unique_head_key = $options['drupalConfig']['rootId'];

    /* JS Tags Start Here */
    // Output the module config to be pushed to initialize.
    $js_config_key = $unique_head_key . '-js-config';

    /* NOTE: The following JS blocks should come after the front-end globals */

    // When making this var we should ensure that 2 different app modules
    // can reside on the same page. 2 instances of the same JS though would
    // not work given the way we load & initialize.
    $settings_var_name = str_replace("-", "_", $js_config_key);
    $build['#attached']['html_head'][] = [
      [
        '#tag' => 'script',
        '#value' => JsAppModuleScriptMarkup::create(
          $this->getInitializeScript($options, $settings_var_name)
        ),
        '#attributes' => [
          'id' => $js_config_key,
        ],
        // Ensure this block is before the script file.
        '#weight' => -10,
      ],
      $js_config_key,
    ];

    // Output the request for the JS File.
    $js_file_key = $unique_head_key . '-js-file';
    $build['#attached']['html_head'][] = [
      [
        '#tag' => 'script',
        '#attributes' => [
          'id' => $js_file_key,
          'src' => $options['drupalConfig']['appJsUri'],
          'onload' => JsAppModuleScriptMarkup::create(
            $this->getOnLoadScript($options, $settings_var_name)
          ),
          'defer' => 'defer',
        ],
        // While this must be after the config, let's get it loaded before the
        // other JS files.
        '#weight' => -1,
      ],
      $js_file_key,
    ];

    $build['#attached']['library'][] = 'cgov_js_app_module/' . $options['drupalConfig']['appName'];

    return $build;
  }

  /**
   * Get the initialize script body.
   *
   * This needs to combine the apps settings with any Drupal variables that
   * are generic to any app. (e.g. canonical host or base url)
   *
   * @param array $options
   *   The app module instance settings.
   * @param string $settings_var_name
   *   The name of the settings var (without window.).
   *
   * @return string
   *   A string representing the script body.
   */
  protected function getInitializeScript(array $options, $settings_var_name) {

    // Start by getting the current URL.
    $drupal_urls = [
      'current' => parse_url(
        Url::fromRoute(
          '<current>',
          [],
          [
            'absolute' => TRUE,
          ]
        )->toString()
      ),
    ];
    // In order to get canonical URLs and whatnot, we need to get the "entity".
    // Now the trick is that only certain types of page-level entities will
    // have URLs we can use. (E.g. Node, media, taxonomy_term?)
    // So for now, we will only support Node.
    $node = \Drupal::routeMatch()->getParameter('node');
    if (is_object($node)) {
      // This should have the canonical and hreflang items.
      foreach ($node->uriRelationships() as $rel) {
        if ($rel === 'canonical') {
          $canonical_url = $node->toUrl($rel)->setAbsolute(TRUE);
          $drupal_urls['canonical'] = parse_url($canonical_url->toString());

          // Now go and get the other languages.
          /** @var \Drupal\Core\Url[] $urls */
          $alternate_urls = array_map(
            function ($language) use ($canonical_url) {
              $url = clone $canonical_url;
              return $url
                ->setOption('language', $language);
            },
            $node->getTranslationLanguages()
          );

          if (count(array_keys($alternate_urls)) > 1) {
            foreach ($alternate_urls as $langcode => $url) {
              $drupal_urls['alternate'][$langcode] = parse_url($url->toString());
            }
          }
        }
      }
    }

    // If there is no frontend config key, then make it an empty array
    // as we need to add some default items. An empty front-end config
    // should be allowed.
    $settings_to_output = !empty($options['frontEndConfig']) ? $options['frontEndConfig'] : [];

    if (gettype($settings_to_output) !== "array") {
      throw new Exception("frontEndConfig can be empty, but if it exists it MUST be an array");
    }

    // Add in our known settings.
    $settings_to_output['baseHost'] = self::NOENC_DIRECTIVE . $drupal_urls['current']['scheme'] .
      '://' .
      $drupal_urls['current']['host'];

    // Gets the base path for the app. The canonical, if it exists, will have
    // the pretty URL for the entity, not the raw route.
    if (array_key_exists('canonical', $drupal_urls)) {
      $settings_to_output['basePath'] = self::NOENC_DIRECTIVE . $drupal_urls['canonical']['path'];
    }
    else {
      // Get the raw route.
      $settings_to_output['basePath'] = self::NOENC_DIRECTIVE . $drupal_urls['current']['basePath'];
    }

    if (array_key_exists('canonical', $drupal_urls)) {
      $settings_to_output['canonicalHost'] = self::NOENC_DIRECTIVE . $drupal_urls['canonical']['scheme'] .
        "://" .
        $drupal_urls['canonical']['host'];
    }
    else {
      $settings_to_output['canonicalHost'] = $settings_to_output['baseHost'];
    }

    $settings_to_output['language'] = $this->languageManager->getCurrentLanguage()->getId();

    $settings_to_output['rootId'] = $options['drupalConfig']['rootId'];

    // Alternate languages.
    if (!empty($drupal_urls['alternate'])) {
      foreach (array_keys($drupal_urls['alternate']) as $lang) {
        $settings_to_output['alternateLanguageUrls'][$lang] =
          self::NOENC_DIRECTIVE .
          ($drupal_urls['alternate'][$lang]['host'] === $drupal_urls['current']['host'] ?
            "" : $drupal_urls['canonical']['scheme'] . "://" . $drupal_urls['canonical']['host']) .
          $drupal_urls['alternate'][$lang]['path'];
      }
    }

    // Setting up token context.
    $token_context = [];
    if (is_object($node)) {
      $token_context['node'] = $node;
    }

    // Let's make this a self executing function.
    $script_body = "(function() {\n\n";

    // Start outputting the settings var.
    $script_body .= "window." . $settings_var_name . " = ";

    // Serialize it.
    $script_body .= $this->objectToString($settings_to_output, $token_context);

    // Close and execute.
    $script_body .= ";\n})();\n";

    return $script_body;
  }

  /**
   * Helper function to translate a setting value to JS value.
   *
   * @param mixed $value
   *   The Value to convert to string.
   * @param array $token_context
   *   The data to use for tokens.
   *
   * @return string
   *   The value as a string.
   */
  protected function settingValueToString($value, array $token_context) {

    $type = gettype($value);

    switch ($type) {
      case "string":
        if (substr($value, 0, strlen(self::LITERAL_DIRECTIVE)) === self::LITERAL_DIRECTIVE) {
          // Do not JSON encode since this is a literal.
          return str_replace(self::LITERAL_DIRECTIVE, "", $value);
        }
        elseif (substr($value, 0, strlen(self::NOENC_DIRECTIVE)) === self::NOENC_DIRECTIVE) {
          return '"' . str_replace(self::NOENC_DIRECTIVE, "", $value) . '"';
        }
        elseif (substr($value, 0, strlen(self::TOKEN_DIRECTIVE)) === self::TOKEN_DIRECTIVE) {
          $token = str_replace(self::TOKEN_DIRECTIVE, "", $value);
          return json_encode($this->tokenService->replace($token, $token_context));
        }
        else {
          return json_encode($value);
        }

      case "array":
        // If the keys are sequential, then it is an array.
        if (array_keys($value) !== range(0, count($value) - 1)) {
          // This is an Object.
          return $this->objectToString($value, $token_context);
        }
        else {
          // This is an array.
          return $this->arrayToString($value, $token_context);
        }

      default:
        return json_encode($value);
    }
  }

  /**
   * Helper function to handle objects.
   */
  protected function objectToString(array $object, array $token_context) {
    $script_body = "{\n";
    // Loop over the items in the settings array.
    $isFirst = TRUE;
    foreach (array_keys($object) as $key) {
      if (!$isFirst) {
        $script_body .= ",\n";
      }
      else {
        $isFirst = FALSE;
      }
      $script_body .= "\t" . '"' . $key . '": ';
      $script_body .= $this->settingValueToString($object[$key], $token_context);
    }
    $script_body .= "\n}";
    return $script_body;
  }

  /**
   * Helper function to handle arrays.
   */
  protected function arrayToString(array $array, array $token_context) {
    $replaced_array = array_map(
      function ($value) use ($token_context) {
        return $this->settingValueToString($value, $token_context);
      },
      $array
    );
    $array_string = "[" . implode(",", $replaced_array) . "]";
    return $array_string;
  }

  /**
   * Gets the script for the on load attribute.
   *
   * This should really be nothing more than window.initfn(window.initvars);
   *
   * @param array $options
   *   The app module instance options.
   * @param string $settings_var_name
   *   The name of the settings var (without window.).
   *
   * @return string
   *   The contents of the onLoad attribute.
   */
  protected function getOnLoadScript(array $options, $settings_var_name) {
    $initFn = $options['drupalConfig']['initFnName'];
    $initVar = "window." . $settings_var_name;

    return $initFn . '(' . $initVar . ")";
  }

  /**
   * {@inheritdoc}
   */
  public function getCacheInfoForRoute($path, array $options = []) {
    $meta = new CacheableMetadata();

    // I don't think we need any other cache tags. The parent app module
    // should have the instance of this app module for clearing if the
    // config is updated. This tag below is a couresy if we need to
    // clear ALL js app modules.
    $meta
      ->setCacheTags(['cgov_js_only_app_module_plugin']);

    return $meta;
  }

  /**
   * {@inheritdoc}
   */
  public function alterPageAttachments(array &$attachments, $path, array $options = []) {

    if (empty($options['drupalConfig']['removeHeadElements'])) {
      return;
    }

    $remove_elements = $options['drupalConfig']['removeHeadElements'];

    // For now rel="alternate" are the only type of head links we will support.
    // If we get more types, then this will need to be more sophisticated.
    $head_elements_to_remove = array_filter($remove_elements, function ($el) {
      return ($el !== "alternate");
    });
    $head_links_to_remove = array_filter($remove_elements, function ($el) {
      return ($el === "alternate");
    });;

    /* -----------
     * Remove head elements
     * -----------
     */
    $remove_head_indices = [];

    foreach ($attachments['#attached']['html_head'] as $delta => $tag) {
      if (in_array($tag[1], $head_elements_to_remove)) {
        $remove_head_indices[] = $delta;
      }
    }

    for ($i = (count($remove_head_indices) - 1); $i >= 0; $i--) {
      unset($attachments['#attached']['html_head'][$remove_head_indices[$i]]);
    }

    /* -----------
     * Remove hreflang links
     * -----------
     */
    $remove_link_indices = [];

    // This applies to all of the views of this app module.
    foreach ($attachments['#attached']['html_head_link'] as $delta => $tag) {
      if (in_array($tag[0]["rel"], $head_links_to_remove)) {
        $remove_link_indices[] = $delta;
      }
    }

    for ($i = (count($remove_link_indices) - 1); $i >= 0; $i--) {
      unset($attachments['#attached']['html_head_link'][$remove_link_indices[$i]]);
    }
  }

}
